mod application;

import io;

class X {
    static X yy;

}


class Main base application#X{

    public static fn main(string[] args) : var {
        __asm(
            ".L1:"
            "movi 3,%adx"
            ".L2:"
            "add %ecx,%ebx"
            "movbi 138.8e+11"
            "movbi #4,#7"
            "movi 138.8e+10, %ecx"
            "_sizeof %egx"
            "goto $L1"
        );

        if(true) {
            Console.write("Hello, World!");
        } else if(true) {
            Console.write("Hello, World!");
        } else {
            Console.write("Hello, World!");
        }
        return b;
    }

// TODO: fix this '.' in front of func call are not checked
// TODO: add check to add 'operator' in front of function ann e if applicable
    var ccx = accb *= 90;
    var accb  += 9 ? 9 : 0;
    var cyy = m + (7 * (+b >> 9)) << x & i;
    var xx = !(++foo(9)[9]).foo(9,9,9,9);//.foo(0,0);
    var x = (dynamic_object)foo(89)[0];
    var y=[7].foo(89).__sizeof(yt).foo(9)[9].foo(8)[90].foo()++;
    var yy = base->application#Main.foo("foo");
    X[] b;
    Main m;

    var c = 99;
    var i = 7 * (+c < 8) < 9;
    string s = "dkdjkn" + i < 9;
    fn foo(var x, var n) : var {

        for(;;) {
            // endless
        }
    }

// TODO: make "expression must evaluate to array" message more clear
// use new enum core_expression to signify function call, field access etc..
// then have a core_expr_string to store helpful data about the expression
    fn operator++ () : Main {
        return self;
    }

    fn operator+(var x) : Main {
        return self;
    }


    fn operator++ (var x, Main b) : Main {
        return self;
    }

    fn foo(var x) : Main[] {

    }

    public static fn main(string[] args) : var {
        Console.write("Hello, World!");
    }
}